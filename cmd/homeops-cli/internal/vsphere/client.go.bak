package vsphere

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/vmware/govmomi"
	"github.com/vmware/govmomi/find"
	"github.com/vmware/govmomi/object"
	"github.com/vmware/govmomi/vim25"
	"github.com/vmware/govmomi/vim25/mo"
	"github.com/vmware/govmomi/vim25/types"
	"homeops-cli/internal/common"
)

// Client represents a vSphere/ESXi client
type Client struct {
	client     *govmomi.Client
	vim        *vim25.Client
	finder     *find.Finder
	logger     *common.ColorLogger
	ctx        context.Context
	cancel     context.CancelFunc
	datacenter *object.Datacenter
}

// NewClient creates a new vSphere client
func NewClient(host, username, password string, insecure bool) *Client {
	return &Client{
		logger: common.NewColorLogger(),
	}
}

// Connect establishes connection to vSphere/ESXi
func (c *Client) Connect(host, username, password string, insecure bool) error {
	c.ctx, c.cancel = context.WithCancel(context.Background())

	// Parse URL
	u, err := url.Parse(fmt.Sprintf("https://%s/sdk", host))
	if err != nil {
		return fmt.Errorf("failed to parse URL: %w", err)
	}
	u.User = url.UserPassword(username, password)

	// Create client
	client, err := govmomi.NewClient(c.ctx, u, insecure)
	if err != nil {
		return fmt.Errorf("failed to create vSphere client: %w", err)
	}

	c.client = client
	c.vim = client.Client
	c.finder = find.NewFinder(c.vim, true)

	// Find datacenter (use default for standalone ESXi)
	datacenter, err := c.finder.DefaultDatacenter(c.ctx)
	if err != nil {
		return fmt.Errorf("failed to find datacenter: %w", err)
	}
	c.datacenter = datacenter
	c.finder.SetDatacenter(datacenter)

	c.logger.Success("Connected to vSphere/ESXi: %s", host)
	return nil
}

// Close closes the vSphere connection
func (c *Client) Close() error {
	// Logout first before canceling context
	if c.client != nil {
		if err := c.client.Logout(c.ctx); err != nil {
			// Cancel context even if logout fails
			if c.cancel != nil {
				c.cancel()
			}
			return err
		}
	}
	// Cancel context after successful logout
	if c.cancel != nil {
		c.cancel()
	}
	return nil
}

// CreateVM creates a new VM with specified configuration
func (c *Client) CreateVM(config VMConfig) (*object.VirtualMachine, error) {
	// Find resource pool (use default for standalone ESXi)
	pool, err := c.finder.DefaultResourcePool(c.ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to find resource pool: %w", err)
	}

	// Find datastore
	datastore, err := c.finder.Datastore(c.ctx, config.Datastore)
	if err != nil {
		return nil, fmt.Errorf("failed to find datastore %s: %w", config.Datastore, err)
	}

	// Find network
	network, err := c.finder.Network(c.ctx, config.Network)
	if err != nil {
		return nil, fmt.Errorf("failed to find network %s: %w", config.Network, err)
	}

	// Find VM folder
	folders, err := c.datacenter.Folders(c.ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get folders: %w", err)
	}

	// Create extra config for specific requirements
	extraConfig := []types.BaseOptionValue{
		&types.OptionValue{Key: "disk.EnableUUID", Value: "TRUE"},
	}

	// Add CPU counter exposure if requested
	if config.ExposeCounters {
		extraConfig = append(extraConfig, &types.OptionValue{Key: "monitor.phys_bits_used", Value: "45"})
	}

	// Create VM spec with basic configuration
	spec := types.VirtualMachineConfigSpec{
		Name:     config.Name,
		GuestId:  "other6xLinux64Guest", // Other 6.x or later Linux (64-bit)
		NumCPUs:  int32(config.VCPUs),   // Set to 8 vCPUs
		MemoryMB: int64(config.Memory),  // Set to 48GB (49152 MB)
		Files: &types.VirtualMachineFileInfo{
			VmPathName: fmt.Sprintf("[%s] %s", config.Datastore, config.Name),
		},
		Firmware: "efi", // Use EFI boot
		BootOptions: &types.VirtualMachineBootOptions{
			EfiSecureBootEnabled: types.NewBool(false), // Disable UEFI secure boot
		},
		Flags: &types.VirtualMachineFlagInfo{
			VirtualMmuUsage:  "automatic",
			VirtualExecUsage: "hvAuto",
			VvtdEnabled:      types.NewBool(config.EnableIOMMU), // Enable IOMMU
		},
		VPMCEnabled: types.NewBool(config.ExposeCounters), // Enable virtualized CPU performance counters
		ExtraConfig: extraConfig,
		// VMware Tools configuration - sync time with host
		Tools: &types.ToolsConfigInfo{
			SyncTimeWithHost: types.NewBool(true),
		},
	}

	// Log IOMMU status
	if config.EnableIOMMU {
		c.logger.Debug("IOMMU/VT-d enabled for VM %s", config.Name)
	}

	// Create only the specific additional devices needed
	var devices []types.BaseVirtualDevice

	// Create NVME controller 0 for boot disk
	nvmeController0 := &types.VirtualNVMEController{
		VirtualController: types.VirtualController{
			VirtualDevice: types.VirtualDevice{
				Key: -100, // Use negative key for automatic assignment
			},
			BusNumber: 0,
		},
	}
	devices = append(devices, nvmeController0)

	// Create NVME controller 1 for Longhorn disk
	nvmeController1 := &types.VirtualNVMEController{
		VirtualController: types.VirtualController{
			VirtualDevice: types.VirtualDevice{
				Key: -101, // Use negative key for automatic assignment
			},
			BusNumber: 1,
		},
	}
	devices = append(devices, nvmeController1)

	// Create boot disk (500GB) on NVME controller 0
	datastoreRef := datastore.Reference()
	bootDisk := &types.VirtualDisk{
		VirtualDevice: types.VirtualDevice{
			Key:           -102, // Use negative key for automatic assignment
			ControllerKey: -100, // NVME controller 0
			UnitNumber:    types.NewInt32(0),
			Backing: &types.VirtualDiskFlatVer2BackingInfo{
				VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
					FileName:  fmt.Sprintf("[%s] %s/%s.vmdk", config.Datastore, config.Name, config.Name),
					Datastore: &datastoreRef,
				},
				DiskMode:        "persistent",
				ThinProvisioned: types.NewBool(true), // Use thin provisioning (matches working manual VM)
				EagerlyScrub:    types.NewBool(false),
			},
		},
		CapacityInKB: int64(config.DiskSize) * 1024 * 1024, // GB to KB
	}
	devices = append(devices, bootDisk)

	// Create Longhorn disk (1TB) on NVME controller 1
	if config.LonghornSize > 0 {
		longhornDisk := &types.VirtualDisk{
			VirtualDevice: types.VirtualDevice{
				Key:           -103, // Use negative key for automatic assignment
				ControllerKey: -101, // NVME controller 1
				UnitNumber:    types.NewInt32(0),
				Backing: &types.VirtualDiskFlatVer2BackingInfo{
					VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
						FileName:  fmt.Sprintf("[%s] %s/%s_1.vmdk", config.Datastore, config.Name, config.Name),
						Datastore: &datastoreRef,
					},
					DiskMode:        "persistent",
					ThinProvisioned: types.NewBool(false), // Use thick provisioning
					EagerlyScrub:    types.NewBool(false), // Lazy zeroed (better for NFS)
				},
			},
			CapacityInKB: int64(config.LonghornSize) * 1024 * 1024, // GB to KB
		}
		devices = append(devices, longhornDisk)
	}

	// Create vmxnet3 network adapter and set to vl999 portgroup
	backing, err := network.EthernetCardBackingInfo(c.ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get network backing: %w", err)
	}

	netDevice := &types.VirtualVmxnet3{
		VirtualVmxnet: types.VirtualVmxnet{
			VirtualEthernetCard: types.VirtualEthernetCard{
				VirtualDevice: types.VirtualDevice{
					Key:     -104, // Use negative key for automatic assignment
					Backing: backing,
					Connectable: &types.VirtualDeviceConnectInfo{
						Connected:         true,
						StartConnected:    true,
						AllowGuestControl: true,
					},
				},
				AddressType: "generated",
			},
		},
	}

	// Set MAC address if provided
	if config.MacAddress != "" {
		netDevice.AddressType = "manual"
		netDevice.MacAddress = config.MacAddress
	}

	devices = append(devices, netDevice)

	// Add CD-ROM with ISO if specified - use SATA controller for CD-ROM
	if config.ISO != "" {
		// Create SATA controller for CD-ROM
		sataController := &types.VirtualAHCIController{
			VirtualSATAController: types.VirtualSATAController{
				VirtualController: types.VirtualController{
					VirtualDevice: types.VirtualDevice{
						Key: -105, // Use negative key for automatic assignment
					},
					BusNumber: 0,
				},
			},
		}
		devices = append(devices, sataController)

		// Create CD-ROM on SATA controller
		cdrom := &types.VirtualCdrom{
			VirtualDevice: types.VirtualDevice{
				Key:           -106, // Use negative key for automatic assignment
				ControllerKey: -105, // SATA controller
				UnitNumber:    types.NewInt32(0),
				Backing: &types.VirtualCdromIsoBackingInfo{
					VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
						FileName:  config.ISO,
						Datastore: &datastoreRef,
					},
				},
				Connectable: &types.VirtualDeviceConnectInfo{
					Connected:         true,
					StartConnected:    true,
					AllowGuestControl: true,
				},
			},
		}
		devices = append(devices, cdrom)
	}

	// Add precision clock device with NTP protocol
	if config.EnablePrecisionClock {
		precisionClock := &types.VirtualPrecisionClock{
			VirtualDevice: types.VirtualDevice{
				Key: -107, // Use negative key for automatic assignment
				Backing: &types.VirtualPrecisionClockSystemClockBackingInfo{
					Protocol: "ntp", // Set protocol to NTP as requested
				},
			},
		}
		devices = append(devices, precisionClock)
	}

	// Add watchdog timer device (set to start with BIOS/UEFI)
	if config.EnableWatchdog {
		watchdog := &types.VirtualWDT{
			VirtualDevice: types.VirtualDevice{
				Key: -108, // Use negative key for automatic assignment
			},
			RunOnBoot: true, // Start with BIOS/UEFI
		}
		devices = append(devices, watchdog)
	}

	// Add devices to spec
	var deviceChanges []types.BaseVirtualDeviceConfigSpec
	for _, device := range devices {
		deviceSpec := &types.VirtualDeviceConfigSpec{
			Operation: types.VirtualDeviceConfigSpecOperationAdd,
			Device:    device,
		}
		// For VirtualDisk devices, specify file operation to create new disk
		if _, isDisk := device.(*types.VirtualDisk); isDisk {
			deviceSpec.FileOperation = types.VirtualDeviceConfigSpecFileOperationCreate
		}
		deviceChanges = append(deviceChanges, deviceSpec)
	}
	spec.DeviceChange = deviceChanges

	// Create VM
	task, err := folders.VmFolder.CreateVM(c.ctx, spec, pool, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create VM: %w", err)
	}

	info, err := task.WaitForResult(c.ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create VM: %w", err)
	}

	vm := object.NewVirtualMachine(c.vim, info.Result.(types.ManagedObjectReference))
	c.logger.Success("VM %s created successfully", config.Name)

	return vm, nil
}

// PowerOnVM powers on a VM
func (c *Client) PowerOnVM(vm *object.VirtualMachine) error {
	task, err := vm.PowerOn(c.ctx)
	if err != nil {
		return fmt.Errorf("failed to power on VM: %w", err)
	}

	_, err = task.WaitForResult(c.ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to power on VM: %w", err)
	}

	c.logger.Success("VM powered on successfully")
	return nil
}

// PowerOffVM powers off a VM
func (c *Client) PowerOffVM(vm *object.VirtualMachine) error {
	task, err := vm.PowerOff(c.ctx)
	if err != nil {
		return fmt.Errorf("failed to power off VM: %w", err)
	}

	if _, err := task.WaitForResult(c.ctx, nil); err != nil {
		return fmt.Errorf("failed to power off VM: %w", err)
	}

	c.logger.Success("VM powered off successfully")
	return nil
}

// DeleteVM deletes a VM
func (c *Client) DeleteVM(vm *object.VirtualMachine) error {
	// Power off if running
	var mvm mo.VirtualMachine
	propErr := vm.Properties(c.ctx, vm.Reference(), []string{"runtime.powerState"}, &mvm)
	if propErr == nil && mvm.Runtime.PowerState == types.VirtualMachinePowerStatePoweredOn {
		c.logger.Info("Powering off VM before deletion...")
		if err := c.PowerOffVM(vm); err != nil {
			c.logger.Warn("Failed to power off VM: %v", err)
		}
	}

	// Delete VM
	task, err := vm.Destroy(c.ctx)
	if err != nil {
		return fmt.Errorf("failed to delete VM: %w", err)
	}

	if _, err := task.WaitForResult(c.ctx, nil); err != nil {
		return fmt.Errorf("failed to delete VM: %w", err)
	}

	c.logger.Success("VM deleted successfully")
	return nil
}

// FindVM finds a VM by name
func (c *Client) FindVM(name string) (*object.VirtualMachine, error) {
	vm, err := c.finder.VirtualMachine(c.ctx, name)
	if err != nil {
		return nil, fmt.Errorf("failed to find VM %s: %w", name, err)
	}
	return vm, nil
}

// ListVMs lists all VMs
func (c *Client) ListVMs() ([]*object.VirtualMachine, error) {
	vms, err := c.finder.VirtualMachineList(c.ctx, "*")
	if err != nil {
		return nil, fmt.Errorf("failed to list VMs: %w", err)
	}
	return vms, nil
}

// GetVMInfo gets detailed VM information
func (c *Client) GetVMInfo(vm *object.VirtualMachine) (*mo.VirtualMachine, error) {
	var mvm mo.VirtualMachine
	err := vm.Properties(c.ctx, vm.Reference(), nil, &mvm)
	if err != nil {
		return nil, fmt.Errorf("failed to get VM properties: %w", err)
	}
	return &mvm, nil
}

// UploadISOToDatastore uploads an ISO file to a vSphere datastore
func (c *Client) UploadISOToDatastore(localFilePath, datastoreName, remoteFileName string) error {
	c.logger.Debug("Uploading ISO %s to datastore %s as %s", localFilePath, datastoreName, remoteFileName)

	// Find the datastore
	datastore, err := c.finder.Datastore(c.ctx, datastoreName)
	if err != nil {
		return fmt.Errorf("failed to find datastore %s: %w", datastoreName, err)
	}

	// Get file info for size logging
	fileInfo, err := os.Stat(localFilePath)
	if err != nil {
		return fmt.Errorf("failed to get file info: %w", err)
	}

	c.logger.Info("Uploading %s (%d MB) to datastore...", remoteFileName, fileInfo.Size()/(1024*1024))

	// Upload file using datastore UploadFile method
	if err := datastore.UploadFile(c.ctx, localFilePath, remoteFileName, nil); err != nil {
		return fmt.Errorf("failed to upload file to datastore: %w", err)
	}

	c.logger.Success("ISO uploaded successfully to [%s] %s", datastoreName, remoteFileName)
	return nil
}

// DeployVMsConcurrently deploys multiple VMs in parallel
func (c *Client) DeployVMsConcurrently(configs []VMConfig) error {
	var wg sync.WaitGroup
	errors := make(chan error, len(configs))

	// Semaphore to limit concurrent deployments (adjust as needed)
	sem := make(chan struct{}, 3)

	for _, config := range configs {
		wg.Add(1)
		go func(cfg VMConfig) {
			defer wg.Done()

			// Acquire semaphore
			sem <- struct{}{}
			defer func() { <-sem }()

			c.logger.Info("Starting deployment of VM: %s", cfg.Name)
			startTime := time.Now()

			// Create VM
			vm, err := c.CreateVM(cfg)
			if err != nil {
				errors <- fmt.Errorf("failed to create VM %s: %w", cfg.Name, err)
				return
			}

			// Power on VM if requested
			if cfg.PowerOn {
				if err := c.PowerOnVM(vm); err != nil {
					errors <- fmt.Errorf("failed to power on VM %s: %w", cfg.Name, err)
					return
				}
			}

			c.logger.Success("VM %s deployed in %v", cfg.Name, time.Since(startTime))
		}(config)
	}

	// Wait for all goroutines to complete
	wg.Wait()
	close(errors)

	// Collect errors
	var allErrors []string
	for err := range errors {
		if err != nil {
			allErrors = append(allErrors, err.Error())
		}
	}

	if len(allErrors) > 0 {
		return fmt.Errorf("deployment errors:\n%s", strings.Join(allErrors, "\n"))
	}

	return nil
}
