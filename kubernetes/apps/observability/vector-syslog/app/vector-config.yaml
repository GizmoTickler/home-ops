---
# Vector configuration for syslog collection from network devices
# Handles multiple syslog formats from Cisco and UniFi devices
apiVersion: v1
kind: ConfigMap
metadata:
  name: vector-syslog
  namespace: observability
data:
  vector.yaml: |-
    # Data directory
    data_dir: /vector-data-dir

    # API for health checks and metrics
    api:
      enabled: true
      address: "0.0.0.0:8686"

    # Sources - Raw UDP socket listeners
    sources:
      cisco_syslog:
        type: socket
        address: "0.0.0.0:514"
        mode: udp
        max_length: 65536
        decoding:
          codec: bytes
        host_key: source_ip

      unifi_syslog:
        type: socket
        address: "0.0.0.0:5514"
        mode: udp
        max_length: 65536
        decoding:
          codec: bytes
        host_key: source_ip

    # Transforms - Parse and enrich messages
    transforms:
      # Parse Cisco messages
      parse_cisco:
        type: remap
        inputs:
          - cisco_syslog
        source: |
          # Convert bytes to string
          .raw_message = to_string!(.message)

          # Extract source device IP
          .device_ip = .source_ip

          # Parse Cisco syslog format
          # Format: <pri>seq: hostname: msgid: timestamp: %facility-severity-mnemonic: message
          if starts_with(.raw_message, "<") {
            # Extract priority
            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .facility = to_int!(.priority / 8)
              .severity = mod!(.priority, 8)

              # Parse the rest of the message
              .remainder = .parts[1]

              # Extract Cisco-specific fields
              .cisco_parts = split!(.remainder, ": ", limit: 6)
              if length(.cisco_parts) >= 5 {
                .sequence = .cisco_parts[0]
                .hostname = .cisco_parts[1]
                .msg_id = .cisco_parts[2]
                .timestamp_str = .cisco_parts[3]

                # Extract facility-severity-mnemonic if present
                if contains(to_string!(.cisco_parts[4]), "%") {
                  .facility_msg = .cisco_parts[4]
                  if exists(.cisco_parts[5]) {
                    .cisco_message = .cisco_parts[5]
                  } else {
                    .cisco_message = ""
                  }
                } else {
                  # Join remaining parts for the message
                  .cisco_message = .cisco_parts[4]
                  if length(.cisco_parts) >= 6 {
                    .cisco_message = to_string!(.cisco_parts[4]) + ": " + to_string!(.cisco_parts[5])
                  }
                }
              }
            }
          }

          # Set final fields for Victoria Logs
          if exists(.cisco_message) {
            ._msg = .cisco_message
          } else {
            ._msg = .raw_message
          }
          ._stream = "network.cisco." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())
          .device_type = "cisco"
          if exists(.hostname) {
            .device_hostname = .hostname
          } else {
            .device_hostname = "unknown"
          }
          .log_source = "network"
          .environment = "production"

          # Determine device name from IP
          if .device_ip == "192.168.120.1" {
            .device_name = "cisco-switch-1"
          } else if .device_ip == "192.168.120.5" {
            .device_name = "cisco-wlc"
          } else {
            .device_name = "cisco-" + to_string!(.device_ip)
          }

          # Clean up intermediate fields
          del(.message)
          del(.parts)
          del(.cisco_parts)
          del(.remainder)
          del(.priority_str)
          del(.source_type)
          del(.port)

      # Parse UniFi messages
      parse_unifi:
        type: remap
        inputs:
          - unifi_syslog
        source: |
          # Convert bytes to string
          .raw_message = to_string!(.message)

          # Extract source device IP
          .device_ip = .source_ip

          # Check message format
          if contains(.raw_message, "CEF:") {
            # CEF format from UniFi Controller
            .message_type = "cef"

            # Parse CEF header
            # Format: timestamp hostname CEF:Version|Vendor|Product|Version|EventID|Name|Severity|Extensions
            .cef_parts = split(.raw_message, " CEF:", limit: 2)
            if length(.cef_parts) >= 2 {
              .header_parts = split!(.cef_parts[0], " ")
              if length(.header_parts) >= 4 {
                .month = .header_parts[0]
                .day = .header_parts[1]
                .time = .header_parts[2]
                .cef_hostname = .header_parts[3]
              }

              # Parse CEF fields
              .cef_data = "CEF:" + to_string!(.cef_parts[1])
              .cef_fields = split(.cef_data, "|")
              if length(.cef_fields) >= 7 {
                .vendor = .cef_fields[1]
                .product = .cef_fields[2]
                .version = .cef_fields[3]
                .event_id = .cef_fields[4]
                .event_name = .cef_fields[5]
                .cef_severity = .cef_fields[6]

                # Parse extensions if present
                if length(.cef_fields) >= 8 {
                  .extensions_str = .cef_fields[7]
                  # Extract msg field from extensions
                  .msg_match = parse_regex(.extensions_str, r'msg=([^=]+(?:\s+[^=]+)*?)(?:\s+\w+=|$)') ?? {}
                  if exists(.msg_match."1") {
                    .parsed_message = .msg_match."1"
                  } else {
                    .parsed_message = .event_name
                  }
                } else {
                  .parsed_message = .event_name
                }
              }
            }

            if exists(.parsed_message) {
              ._msg = .parsed_message
            } else {
              ._msg = .raw_message
            }
            .device_name = "unifi-controller"

          } else if starts_with(.raw_message, "<") {
            # Standard syslog format from UXG
            .message_type = "syslog"

            # Extract priority
            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .facility = to_int!(.priority / 8)
              .severity = mod!(.priority, 8)

              # Parse the message
              .msg_content = .parts[1]

              # Check if it's a firewall log
              if contains(to_string!(.msg_content), "DESCR=") {
                .message_type = "firewall"
                ._msg = .msg_content
                .device_name = "unifi-uxg-firewall"

                # Extract network fields from firewall log
                # Extract interfaces
                .in_match = parse_regex(.msg_content, r'IN=([^\s]+)') ?? {}
                if exists(.in_match."1") {
                  .in_interface = string!(.in_match."1")
                }

                .out_match = parse_regex(.msg_content, r'OUT=([^\s]+)') ?? {}
                if exists(.out_match."1") {
                  .out_interface = string!(.out_match."1")
                }

                # Extract MAC addresses
                .mac_match = parse_regex(.msg_content, r'MAC=([^\s]+)') ?? {}
                if exists(.mac_match."1") {
                  .mac_address = string!(.mac_match."1")
                  # Split MAC into src and dst (first 17 chars is dst, next 17 is src)
                  if length(.mac_address) >= 35 {
                    .dst_mac = slice!(.mac_address, 0, 17)
                    .src_mac = slice!(.mac_address, 18, 35)
                  }
                }

                # Extract IP addresses
                .src_ip_match = parse_regex(.msg_content, r'SRC=([^\s]+)') ?? {}
                if exists(.src_ip_match."1") {
                  .src_ip = string!(.src_ip_match."1")
                  # Determine IP type
                  if contains(.src_ip, ":") {
                    .src_ip_type = "ipv6"
                  } else {
                    .src_ip_type = "ipv4"
                  }
                }

                .dst_ip_match = parse_regex(.msg_content, r'DST=([^\s]+)') ?? {}
                if exists(.dst_ip_match."1") {
                  .dst_ip = string!(.dst_ip_match."1")
                  # Determine IP type
                  if contains(.dst_ip, ":") {
                    .dst_ip_type = "ipv6"
                  } else {
                    .dst_ip_type = "ipv4"
                  }
                }

                # Extract ports
                .src_port_match = parse_regex(.msg_content, r'SPT=(\d+)') ?? {}
                if exists(.src_port_match."1") {
                  .src_port = to_int!(.src_port_match."1")
                }

                .dst_port_match = parse_regex(.msg_content, r'DPT=(\d+)') ?? {}
                if exists(.dst_port_match."1") {
                  .dst_port = to_int!(.dst_port_match."1")
                }

                # Extract protocol
                .proto_match = parse_regex(.msg_content, r'PROTO=([^\s]+)') ?? {}
                if exists(.proto_match."1") {
                  .protocol = string!(.proto_match."1")
                }

                # Extract packet length
                .len_match = parse_regex(.msg_content, r'LEN=(\d+)') ?? {}
                if exists(.len_match."1") {
                  .packet_length = to_int!(.len_match."1")
                }

                # Extract TTL/HOPLIMIT
                .ttl_match = parse_regex(.msg_content, r'TTL=(\d+)') ?? {}
                if exists(.ttl_match."1") {
                  .ttl = to_int!(.ttl_match."1")
                }

                .hoplimit_match = parse_regex(.msg_content, r'HOPLIMIT=(\d+)') ?? {}
                if exists(.hoplimit_match."1") {
                  .hop_limit = to_int!(.hoplimit_match."1")
                }

                # Extract TCP flags
                .msg_str = to_string!(.msg_content)
                if contains(.msg_str, " SYN ") {
                  .tcp_flags = "SYN"
                }
                if contains(.msg_str, " ACK ") {
                  if exists(.tcp_flags) {
                    .tcp_flags = .tcp_flags + ",ACK"
                  } else {
                    .tcp_flags = "ACK"
                  }
                }
                if contains(.msg_str, " FIN ") {
                  if exists(.tcp_flags) {
                    .tcp_flags = .tcp_flags + ",FIN"
                  } else {
                    .tcp_flags = "FIN"
                  }
                }
                if contains(.msg_str, " RST ") {
                  if exists(.tcp_flags) {
                    .tcp_flags = .tcp_flags + ",RST"
                  } else {
                    .tcp_flags = "RST"
                  }
                }
                del(.msg_str)

                # Determine traffic direction
                if exists(.src_ip) && exists(.dst_ip) {
                  if starts_with(.src_ip, "192.168.") || starts_with(.src_ip, "10.") || starts_with(.src_ip, "172.") {
                    if starts_with(.dst_ip, "192.168.") || starts_with(.dst_ip, "10.") || starts_with(.dst_ip, "172.") {
                      .traffic_direction = "internal"
                    } else {
                      .traffic_direction = "outbound"
                    }
                  } else {
                    .traffic_direction = "inbound"
                  }
                }

                # Clean up temporary match fields
                del(.in_match)
                del(.out_match)
                del(.mac_match)
                del(.src_ip_match)
                del(.dst_ip_match)
                del(.src_port_match)
                del(.dst_port_match)
                del(.proto_match)
                del(.len_match)
                del(.ttl_match)
                del(.hoplimit_match)
              } else {
                # System log
                ._msg = .msg_content
                .device_name = "unifi-uxg-system"
              }
            }
          } else {
            # Unknown format
            ._msg = .raw_message
            .device_name = "unifi-unknown"
          }

          # Set final fields for Victoria Logs
          ._stream = "network.unifi." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())
          .device_type = "unifi"
          .log_source = "network"
          .environment = "production"

          # Clean up intermediate fields
          del(.message)
          del(.parts)
          del(.cef_parts)
          del(.cef_fields)
          del(.header_parts)
          del(.extensions_str)
          del(.msg_match)
          del(.priority_str)
          del(.source_type)
          del(.port)
          del(.cef_data)

    # Sinks - Send to Victoria Logs
    sinks:
      victoria_logs:
        type: http
        inputs:
          - parse_cisco
          - parse_unifi
        uri: "http://victoria-logs-server.observability.svc.cluster.local:9428/insert/jsonline"
        method: post
        compression: gzip
        framing:
          method: newline_delimited
        encoding:
          codec: json
          only_fields:
            - _msg
            - _stream
            - _time
            - device_type
            - device_name
            - device_ip
            - device_hostname
            - log_source
            - environment
            - facility
            - severity
            - sequence
            - msg_id
            - event_id
            - event_name
            - vendor
            - product
            - version
            - message_type
            - raw_message
            # Network fields
            - src_ip
            - dst_ip
            - src_port
            - dst_port
            - protocol
            - src_ip_type
            - dst_ip_type
            - traffic_direction
            - mac_address
            - src_mac
            - dst_mac
            - in_interface
            - out_interface
            - packet_length
            - ttl
            - hop_limit
            - tcp_flags
        batch:
          max_bytes: 1048576
          max_events: 1000
          timeout_secs: 5
        buffer:
          type: memory
          max_events: 10000
        request:
          headers:
            Content-Type: "application/x-ndjson"
        healthcheck:
          enabled: true

      # Debug output to console
      debug_console:
        type: console
        inputs:
          - parse_cisco
          - parse_unifi
        encoding:
          codec: json
          only_fields:
            - _msg
            - _stream
            - _time
            - device_type
            - device_name
            - device_ip
            - message_type
            - src_ip
            - dst_ip
            - src_port
            - dst_port
            - protocol
        target: stdout
