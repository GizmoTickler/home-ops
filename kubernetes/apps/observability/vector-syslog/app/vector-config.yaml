---
# Vector configuration for syslog collection from network devices
# Handles multiple syslog formats from Cisco, OPNsense, and UniFi devices
#
# Device Configuration:
#   - Cisco switch (10.255.255.1) -> UDP 514
#   - OPNsense (10.255.255.2) -> UDP 5514
#   - UniFi devices -> UDP 5514
#
# LoadBalancer IP: 192.168.255.254
apiVersion: v1
kind: ConfigMap
metadata:
  name: vector-syslog-config
  namespace: observability
data:
  aggregator.yaml: |-
    # Data directory for disk buffer
    data_dir: /vector-data-dir

    # API for health checks and metrics
    api:
      enabled: true
      address: "0.0.0.0:8686"

    # Sources - Raw UDP socket listeners
    sources:
      # Cisco syslog on UDP 514
      cisco_syslog:
        type: socket
        address: "0.0.0.0:514"
        mode: udp
        max_length: 65536
        decoding:
          codec: bytes
        host_key: source_ip

      # OPNsense and UniFi syslog on UDP 5514
      network_syslog:
        type: socket
        address: "0.0.0.0:5514"
        mode: udp
        max_length: 65536
        decoding:
          codec: bytes
        host_key: source_ip

    # Transforms - Parse and enrich messages
    transforms:
      # Route network_syslog based on source IP
      route_by_source:
        type: route
        inputs:
          - network_syslog
        route:
          opnsense: '.source_ip == "10.255.255.2"'
          unifi: '.source_ip != "10.255.255.2"'

      # Parse Cisco switch messages (10.255.255.1)
      parse_cisco:
        type: remap
        inputs:
          - cisco_syslog
        source: |
          # Convert bytes to string
          .raw_message = to_string!(.message)
          .device_ip = .source_ip

          # Parse Cisco syslog format
          # Format: <pri>seq: hostname: msgid: timestamp: %facility-severity-mnemonic: message
          if starts_with(.raw_message, "<") {
            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .facility = to_int!(.priority / 8)
              .severity = mod!(.priority, 8)
              severity_names = ["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
              .severity_name = get!(severity_names, [.severity]) ?? "debug"

              .remainder = .parts[1]
              .cisco_parts = split!(.remainder, ": ", limit: 6)

              if length(.cisco_parts) >= 5 {
                .sequence = .cisco_parts[0]
                .hostname = .cisco_parts[1]
                .msg_id = .cisco_parts[2]
                .timestamp_str = .cisco_parts[3]

                if contains(to_string!(.cisco_parts[4]), "%") {
                  .facility_msg = .cisco_parts[4]
                  # Extract facility-severity-mnemonic
                  .fsm_match = parse_regex(to_string!(.facility_msg), r'%(?P<facility_name>\w+)-(?P<sev>\d+)-(?P<mnemonic>\w+)') ?? {}
                  if exists(.fsm_match.facility_name) {
                    .cisco_facility = .fsm_match.facility_name
                    .cisco_severity = to_int(.fsm_match.sev) ?? 6
                    .cisco_mnemonic = .fsm_match.mnemonic
                  }
                  if exists(.cisco_parts[5]) {
                    .cisco_message = .cisco_parts[5]
                  } else {
                    .cisco_message = ""
                  }
                } else {
                  .cisco_message = .cisco_parts[4]
                  if length(.cisco_parts) >= 6 {
                    .cisco_message = to_string!(.cisco_parts[4]) + ": " + to_string!(.cisco_parts[5])
                  }
                }
              }
            }
          }

          # Set final fields
          if exists(.cisco_message) {
            ._msg = .cisco_message
          } else {
            ._msg = .raw_message
          }

          ._stream = "network.cisco." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())
          .device_type = "cisco"
          .device_name = if .device_ip == "10.255.255.1" { "cisco-switch" } else { "cisco-" + to_string!(.device_ip) }
          .device_hostname = .hostname ?? "unknown"
          .log_source = "network"
          .environment = "production"

          # Cleanup
          del(.message)
          del(.parts)
          del(.cisco_parts)
          del(.remainder)
          del(.priority_str)
          del(.source_type)
          del(.port)
          del(.fsm_match)

      # Rate limit Cisco logs
      rate_limit_cisco:
        type: throttle
        inputs:
          - parse_cisco
        key_field: device_ip
        threshold: 1000
        window_secs: 1

      # Parse OPNsense firewall messages (10.255.255.2)
      parse_opnsense:
        type: remap
        inputs:
          - route_by_source.opnsense
        source: |
          .raw_message = to_string!(.message)
          .device_ip = .source_ip
          .device_type = "opnsense"
          .device_name = "opnsense-firewall"
          .log_source = "network"
          .environment = "production"
          ._stream = "network.opnsense." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())

          # Parse RFC5424 syslog format
          if starts_with(.raw_message, "<") {
            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .facility = to_int!(.priority / 8)
              .severity = mod!(.priority, 8)
              severity_names = ["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
              .severity_name = get!(severity_names, [.severity]) ?? "debug"

              .remainder = .parts[1]

              # RFC5424: version SP timestamp SP hostname SP app-name SP procid SP msgid SP SD SP msg
              .rfc5424_parts = split!(.remainder, " ")

              if length(.rfc5424_parts) >= 7 {
                .syslog_version = .rfc5424_parts[0]
                .syslog_timestamp = .rfc5424_parts[1]
                .device_hostname = .rfc5424_parts[2]
                .app_name = .rfc5424_parts[3]
                .proc_id = .rfc5424_parts[4]
                .msg_id = .rfc5424_parts[5]

                # Get structured data and message
                .sd_and_msg = join!(slice!(.rfc5424_parts, 6), " ")

                if starts_with(.sd_and_msg, "[") {
                  .sd_msg_parts = split!(.sd_and_msg, "] ")
                  if length(.sd_msg_parts) >= 2 {
                    .structured_data = string!(.sd_msg_parts[0]) + "]"
                    .msg_content = join!(slice!(.sd_msg_parts, 1), "] ")
                  } else {
                    .structured_data = .sd_and_msg
                    .msg_content = ""
                  }
                } else {
                  .sd_parts_simple = split!(.sd_and_msg, " ", limit: 2)
                  .structured_data = .sd_parts_simple[0]
                  .msg_content = if length(.sd_parts_simple) >= 2 { .sd_parts_simple[1] } else { "" }
                }

                # Parse filterlog (firewall) messages
                if .app_name == "filterlog" {
                  .message_type = "filterlog"
                  .log_type = "firewall"
                  .application = "filterlog"

                  .fields = split!(.msg_content, ",")
                  .field_count = length(.fields)

                  if .field_count >= 9 {
                    .rule_number = .fields[0]
                    .sub_rule = .fields[1]
                    .anchor = .fields[2]
                    .tracker = .fields[3]
                    .interface = .fields[4]
                    .reason = .fields[5]
                    .action = .fields[6]
                    .direction = .fields[7]
                    .ip_version = .fields[8]

                    # IPv4 parsing
                    if .ip_version == "4" && .field_count >= 18 {
                      .tos = .fields[9]
                      .ecn = .fields[10]
                      .ttl = to_int(.fields[11]) ?? null
                      .packet_id = .fields[12]
                      .offset = .fields[13]
                      .ip_flags = .fields[14]
                      .protocol_id = .fields[15]
                      .protocol = downcase!(string!(.fields[16]))
                      .packet_length = to_int(.fields[17]) ?? null

                      if (.protocol == "tcp" || .protocol == "udp") && .field_count >= 23 {
                        .src_ip = .fields[18]
                        .dst_ip = .fields[19]
                        .src_port = to_int(.fields[20]) ?? null
                        .dst_port = to_int(.fields[21]) ?? null
                        .data_length = to_int(.fields[22]) ?? null

                        if .protocol == "tcp" && .field_count >= 24 {
                          .tcp_flags = .fields[23]
                        }
                      } else if .protocol == "icmp" && .field_count >= 22 {
                        .src_ip = .fields[18]
                        .dst_ip = .fields[19]
                        .icmp_type = .fields[20]
                        .icmp_code = .fields[21]
                      } else if .field_count >= 20 {
                        .src_ip = .fields[18]
                        .dst_ip = .fields[19]
                      }

                    # IPv6 parsing
                    } else if .ip_version == "6" && .field_count >= 15 {
                      .hop_limit = to_int(.fields[11]) ?? null
                      .protocol = downcase!(string!(.fields[12]))
                      .protocol_id = .fields[13]
                      .packet_length = to_int(.fields[14]) ?? null

                      if (.protocol == "tcp" || .protocol == "udp") && .field_count >= 20 {
                        .src_ip = .fields[15]
                        .dst_ip = .fields[16]
                        .src_port = to_int(.fields[17]) ?? null
                        .dst_port = to_int(.fields[18]) ?? null
                      }
                    }

                    # Traffic direction
                    if exists(.src_ip) && exists(.dst_ip) {
                      .src_ip_str = string!(.src_ip)
                      .dst_ip_str = string!(.dst_ip)

                      .src_is_private = starts_with(.src_ip_str, "192.168.") || starts_with(.src_ip_str, "10.") ||
                        starts_with(.src_ip_str, "172.16.") || starts_with(.src_ip_str, "172.17.") ||
                        starts_with(.src_ip_str, "172.18.") || starts_with(.src_ip_str, "172.19.") ||
                        starts_with(.src_ip_str, "172.20.") || starts_with(.src_ip_str, "172.21.") ||
                        starts_with(.src_ip_str, "172.22.") || starts_with(.src_ip_str, "172.23.") ||
                        starts_with(.src_ip_str, "172.24.") || starts_with(.src_ip_str, "172.25.") ||
                        starts_with(.src_ip_str, "172.26.") || starts_with(.src_ip_str, "172.27.") ||
                        starts_with(.src_ip_str, "172.28.") || starts_with(.src_ip_str, "172.29.") ||
                        starts_with(.src_ip_str, "172.30.") || starts_with(.src_ip_str, "172.31.")

                      .dst_is_private = starts_with(.dst_ip_str, "192.168.") || starts_with(.dst_ip_str, "10.") ||
                        starts_with(.dst_ip_str, "172.16.") || starts_with(.dst_ip_str, "172.17.") ||
                        starts_with(.dst_ip_str, "172.18.") || starts_with(.dst_ip_str, "172.19.") ||
                        starts_with(.dst_ip_str, "172.20.") || starts_with(.dst_ip_str, "172.21.") ||
                        starts_with(.dst_ip_str, "172.22.") || starts_with(.dst_ip_str, "172.23.") ||
                        starts_with(.dst_ip_str, "172.24.") || starts_with(.dst_ip_str, "172.25.") ||
                        starts_with(.dst_ip_str, "172.26.") || starts_with(.dst_ip_str, "172.27.") ||
                        starts_with(.dst_ip_str, "172.28.") || starts_with(.dst_ip_str, "172.29.") ||
                        starts_with(.dst_ip_str, "172.30.") || starts_with(.dst_ip_str, "172.31.")

                      .traffic_direction = if .src_is_private && .dst_is_private { "internal" } else if .src_is_private { "outbound" } else { "inbound" }

                      del(.src_ip_str)
                      del(.dst_ip_str)
                      del(.src_is_private)
                      del(.dst_is_private)
                    }

                    # Build message
                    .action_str = upcase!(string!(.action))
                    if exists(.src_ip) && exists(.dst_ip) {
                      if exists(.src_port) && exists(.dst_port) {
                        ._msg = string!(.action_str) + " " + string!(.protocol) + " " + string!(.src_ip) + ":" + to_string!(.src_port) + " -> " + string!(.dst_ip) + ":" + to_string!(.dst_port) + " on " + string!(.interface)
                      } else {
                        ._msg = string!(.action_str) + " " + string!(.protocol) + " " + string!(.src_ip) + " -> " + string!(.dst_ip) + " on " + string!(.interface)
                      }
                    } else {
                      ._msg = .msg_content
                    }
                  } else {
                    ._msg = .msg_content
                  }

                # Parse other OPNsense services
                } else if contains(.app_name, "unbound") {
                  .log_type = "dns"
                  .application = "unbound"
                  .message_type = "system"
                  ._msg = .msg_content
                  .device_name = "opnsense-dns"
                } else if contains(.app_name, "dhcpd") {
                  .log_type = "dhcp"
                  .application = "dhcpd"
                  .message_type = "system"
                  ._msg = .msg_content
                  .device_name = "opnsense-dhcp"
                } else if contains(.app_name, "openvpn") || contains(.app_name, "wireguard") {
                  .log_type = "vpn"
                  .application = .app_name
                  .message_type = "system"
                  ._msg = .msg_content
                  .device_name = "opnsense-vpn"
                } else if contains(.app_name, "suricata") {
                  .log_type = "ids"
                  .application = "suricata"
                  .message_type = "system"
                  ._msg = .msg_content
                  .device_name = "opnsense-ids"
                } else if contains(.app_name, "sshd") || contains(.app_name, "audit") {
                  .log_type = "auth"
                  .application = .app_name
                  .message_type = "system"
                  ._msg = .msg_content
                  .device_name = "opnsense-auth"
                } else {
                  .log_type = "system"
                  .application = .app_name
                  .message_type = "system"
                  ._msg = string!(.app_name) + ": " + string!(.msg_content)
                  .device_name = "opnsense-system"
                }
              }
            }
          } else {
            ._msg = .raw_message
            .message_type = "unknown"
          }

          # Cleanup
          del(.message)
          del(.parts)
          del(.rfc5424_parts)
          del(.sd_and_msg)
          del(.sd_msg_parts)
          del(.sd_parts_simple)
          del(.structured_data)
          del(.msg_content)
          del(.fields)
          del(.field_count)
          del(.remainder)
          del(.priority_str)
          del(.source_type)
          del(.port)
          del(.action_str)

      # Rate limit OPNsense logs
      rate_limit_opnsense:
        type: throttle
        inputs:
          - parse_opnsense
        key_field: device_ip
        threshold: 5000
        window_secs: 1

      # Parse UniFi messages
      parse_unifi:
        type: remap
        inputs:
          - route_by_source.unifi
        source: |
          .raw_message = to_string!(.message)
          .device_ip = .source_ip
          .device_type = "unifi"
          .log_source = "network"
          .environment = "production"
          ._stream = "network.unifi." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())

          # CEF format from UniFi Controller
          if contains(.raw_message, "CEF:") {
            .message_type = "cef"

            .cef_parts = split(.raw_message, " CEF:", limit: 2)
            if length(.cef_parts) >= 2 {
              .cef_data = "CEF:" + to_string!(.cef_parts[1])
              .cef_fields = split(.cef_data, "|")
              if length(.cef_fields) >= 7 {
                .vendor = .cef_fields[1]
                .product = .cef_fields[2]
                .version = .cef_fields[3]
                .event_id = .cef_fields[4]
                .event_name = .cef_fields[5]
                .cef_severity = .cef_fields[6]

                if length(.cef_fields) >= 8 {
                  .msg_match = parse_regex(.cef_fields[7], r'msg=([^=]+(?:\s+[^=]+)*?)(?:\s+\w+=|$)') ?? {}
                  ._msg = .msg_match."1" ?? .event_name
                } else {
                  ._msg = .event_name
                }
              }
            }
            .device_name = "unifi-controller"

          # iptables format from UXG
          } else if starts_with(.raw_message, "<") && contains(.raw_message, "DESCR=") {
            .message_type = "firewall"

            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .severity = mod!(.priority, 8)
              .msg_content = .parts[1]
              ._msg = .msg_content

              .msg_str = string!(.msg_content)

              # Extract fields
              if contains(.msg_str, "SRC=") {
                .src_parts = split(.msg_str, "SRC=")
                if length(.src_parts) >= 2 {
                  .src_value_parts = split!(string!(.src_parts[1]), " ")
                  .src_ip = .src_value_parts[0]
                }
              }
              if contains(.msg_str, "DST=") {
                .dst_parts = split(.msg_str, "DST=")
                if length(.dst_parts) >= 2 {
                  .dst_value_parts = split!(string!(.dst_parts[1]), " ")
                  .dst_ip = .dst_value_parts[0]
                }
              }
              if contains(.msg_str, "SPT=") {
                .spt_parts = split(.msg_str, "SPT=")
                if length(.spt_parts) >= 2 {
                  .spt_value_parts = split!(string!(.spt_parts[1]), " ")
                  .src_port = to_int!(.spt_value_parts[0])
                }
              }
              if contains(.msg_str, "DPT=") {
                .dpt_parts = split(.msg_str, "DPT=")
                if length(.dpt_parts) >= 2 {
                  .dpt_value_parts = split!(string!(.dpt_parts[1]), " ")
                  .dst_port = to_int!(.dpt_value_parts[0])
                }
              }
              if contains(.msg_str, "PROTO=") {
                .proto_parts = split(.msg_str, "PROTO=")
                if length(.proto_parts) >= 2 {
                  .proto_value_parts = split!(string!(.proto_parts[1]), " ")
                  .protocol = .proto_value_parts[0]
                }
              }

              # Traffic direction
              if exists(.src_ip) && exists(.dst_ip) {
                .src_ip_str = string!(.src_ip)
                .dst_ip_str = string!(.dst_ip)
                .src_is_private = starts_with(.src_ip_str, "192.168.") || starts_with(.src_ip_str, "10.")
                .dst_is_private = starts_with(.dst_ip_str, "192.168.") || starts_with(.dst_ip_str, "10.")
                .traffic_direction = if .src_is_private && .dst_is_private { "internal" } else if .src_is_private { "outbound" } else { "inbound" }
              }
            }
            .device_name = "unifi-uxg-firewall"

          } else {
            ._msg = .raw_message
            .device_name = "unifi-unknown"
          }

          # Cleanup
          del(.message)
          del(.parts)
          del(.cef_parts)
          del(.cef_fields)
          del(.cef_data)
          del(.msg_match)
          del(.priority_str)
          del(.source_type)
          del(.port)
          del(.msg_content)
          del(.msg_str)
          del(.src_parts)
          del(.dst_parts)
          del(.spt_parts)
          del(.dpt_parts)
          del(.proto_parts)
          del(.src_value_parts)
          del(.dst_value_parts)
          del(.spt_value_parts)
          del(.dpt_value_parts)
          del(.proto_value_parts)
          del(.src_ip_str)
          del(.dst_ip_str)
          del(.src_is_private)
          del(.dst_is_private)

      # Rate limit UniFi logs
      rate_limit_unifi:
        type: throttle
        inputs:
          - parse_unifi
        key_field: device_ip
        threshold: 3000
        window_secs: 1

    # Sinks - Send to Victoria Logs
    sinks:
      victoria_logs:
        type: http
        inputs:
          - rate_limit_cisco
          - rate_limit_opnsense
          - rate_limit_unifi
        uri: "http://victoria-logs-server.observability.svc.cluster.local:9428/insert/jsonline"
        method: post
        compression: gzip
        framing:
          method: newline_delimited
        encoding:
          codec: json
          only_fields:
            - _msg
            - _stream
            - _time
            # Common fields
            - device_type
            - device_name
            - device_ip
            - device_hostname
            - log_source
            - log_type
            - application
            - environment
            - facility
            - severity
            - severity_name
            - raw_message
            - message_type
            # Cisco-specific
            - sequence
            - msg_id
            - timestamp_str
            - facility_msg
            - cisco_facility
            - cisco_severity
            - cisco_mnemonic
            # OPNsense-specific
            - app_name
            - rule_number
            - tracker
            - interface
            - reason
            - action
            - direction
            - ip_version
            - ip_flags
            # Network fields
            - src_ip
            - dst_ip
            - src_port
            - dst_port
            - protocol
            - traffic_direction
            - packet_length
            - ttl
            - hop_limit
            - tcp_flags
            - icmp_type
            - icmp_code
            # UniFi CEF
            - event_id
            - event_name
            - vendor
            - product
            - version
        batch:
          max_bytes: 5242880
          max_events: 5000
          timeout_secs: 10
        buffer:
          type: disk
          max_size: 268435488
          when_full: block
        request:
          headers:
            Content-Type: "application/x-ndjson"
          retry_initial_backoff_secs: 1
          retry_max_duration_secs: 300
        healthcheck:
          enabled: true
