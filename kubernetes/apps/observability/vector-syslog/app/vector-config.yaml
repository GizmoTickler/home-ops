---
# Vector configuration for syslog collection from network devices
# Handles multiple syslog formats from Cisco and UniFi devices
apiVersion: v1
kind: ConfigMap
metadata:
  name: vector-syslog
  namespace: observability
data:
  vector.yaml: |-
    # Data directory
    data_dir: /vector-data-dir

    # API for health checks and metrics
    api:
      enabled: true
      address: "0.0.0.0:8686"

    # Sources - Raw UDP socket listeners
    sources:
      cisco_syslog:
        type: socket
        address: "0.0.0.0:514"
        mode: udp
        max_length: 65536
        decoding:
          codec: bytes
        host_key: source_ip

      unifi_syslog:
        type: socket
        address: "0.0.0.0:5514"
        mode: udp
        max_length: 65536
        decoding:
          codec: bytes
        host_key: source_ip

    # Transforms - Parse and enrich messages
    transforms:
      # Parse Cisco messages
      parse_cisco:
        type: remap
        inputs:
          - cisco_syslog
        source: |
          # Convert bytes to string
          .raw_message = to_string!(.message)

          # Extract source device IP
          .device_ip = .source_ip

          # Parse Cisco syslog format
          # Format: <pri>seq: hostname: msgid: timestamp: %facility-severity-mnemonic: message
          if starts_with(.raw_message, "<") {
            # Extract priority
            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .facility = to_int!(.priority / 8)
              .severity = mod!(.priority, 8)

              # Parse the rest of the message
              .remainder = .parts[1]

              # Extract Cisco-specific fields
              .cisco_parts = split!(.remainder, ": ", limit: 6)
              if length(.cisco_parts) >= 5 {
                .sequence = .cisco_parts[0]
                .hostname = .cisco_parts[1]
                .msg_id = .cisco_parts[2]
                .timestamp_str = .cisco_parts[3]

                # Extract facility-severity-mnemonic if present
                if contains(to_string!(.cisco_parts[4]), "%") {
                  .facility_msg = .cisco_parts[4]
                  if exists(.cisco_parts[5]) {
                    .cisco_message = .cisco_parts[5]
                  } else {
                    .cisco_message = ""
                  }
                } else {
                  # Join remaining parts for the message
                  .cisco_message = .cisco_parts[4]
                  if length(.cisco_parts) >= 6 {
                    .cisco_message = to_string!(.cisco_parts[4]) + ": " + to_string!(.cisco_parts[5])
                  }
                }
              }
            }
          }

          # Set final fields for Victoria Logs
          if exists(.cisco_message) {
            ._msg = .cisco_message
          } else {
            ._msg = .raw_message
          }
          ._stream = "network.cisco." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())
          .device_type = "cisco"
          if exists(.hostname) {
            .device_hostname = .hostname
          } else {
            .device_hostname = "unknown"
          }
          .log_source = "network"
          .environment = "production"

          # Determine device name from IP
          if .device_ip == "192.168.120.1" {
            .device_name = "cisco-switch-1"
          } else if .device_ip == "192.168.120.5" {
            .device_name = "cisco-wlc"
          } else {
            .device_name = "cisco-" + to_string!(.device_ip)
          }

          # Clean up intermediate fields
          del(.message)
          del(.parts)
          del(.cisco_parts)
          del(.remainder)
          del(.priority_str)
          del(.source_type)
          del(.port)

      # Parse UniFi messages
      parse_unifi:
        type: remap
        inputs:
          - unifi_syslog
        source: |
          # Convert bytes to string
          .raw_message = to_string!(.message)

          # Extract source device IP
          .device_ip = .source_ip

          # Check message format
          if contains(.raw_message, "CEF:") {
            # CEF format from UniFi Controller
            .message_type = "cef"

            # Parse CEF header
            # Format: timestamp hostname CEF:Version|Vendor|Product|Version|EventID|Name|Severity|Extensions
            .cef_parts = split(.raw_message, " CEF:", limit: 2)
            if length(.cef_parts) >= 2 {
              .header_parts = split!(.cef_parts[0], " ")
              if length(.header_parts) >= 4 {
                .month = .header_parts[0]
                .day = .header_parts[1]
                .time = .header_parts[2]
                .cef_hostname = .header_parts[3]
              }

              # Parse CEF fields
              .cef_data = "CEF:" + to_string!(.cef_parts[1])
              .cef_fields = split(.cef_data, "|")
              if length(.cef_fields) >= 7 {
                .vendor = .cef_fields[1]
                .product = .cef_fields[2]
                .version = .cef_fields[3]
                .event_id = .cef_fields[4]
                .event_name = .cef_fields[5]
                .cef_severity = .cef_fields[6]

                # Parse extensions if present
                if length(.cef_fields) >= 8 {
                  .extensions_str = .cef_fields[7]
                  # Extract msg field from extensions
                  .msg_match = parse_regex(.extensions_str, r'msg=([^=]+(?:\s+[^=]+)*?)(?:\s+\w+=|$)') ?? {}
                  if exists(.msg_match."1") {
                    .parsed_message = .msg_match."1"
                  } else {
                    .parsed_message = .event_name
                  }
                } else {
                  .parsed_message = .event_name
                }
              }
            }

            if exists(.parsed_message) {
              ._msg = .parsed_message
            } else {
              ._msg = .raw_message
            }
            .device_name = "unifi-controller"

          } else if starts_with(.raw_message, "<") {
            # Standard syslog format from UXG
            .message_type = "syslog"

            # Extract priority
            .parts = split(.raw_message, ">", limit: 2)
            if length(.parts) >= 2 {
              .priority_str = replace!(.parts[0], "<", "")
              .priority = to_int!(.priority_str)
              .facility = to_int!(.priority / 8)
              .severity = mod!(.priority, 8)

              # Parse the message
              .msg_content = .parts[1]

              # Check if it's a firewall log
              if contains(to_string!(.msg_content), "DESCR=") {
                .message_type = "firewall"
                ._msg = .msg_content
                .device_name = "unifi-uxg-firewall"

                # Extract network fields from firewall log
                # Extract interfaces using proper VRL syntax
                .msg_str = string!(.msg_content)

                # Extract IN interface
                if contains(.msg_str, "IN=") {
                  .in_parts = split(.msg_str, "IN=")
                  if length(.in_parts) >= 2 {
                    .after_in = .in_parts[1]
                    .in_value_parts = split!(.after_in, " ")
                    if length(.in_value_parts) >= 1 {
                      .in_interface = .in_value_parts[0]
                    }
                  }
                  del(.in_parts)
                  del(.after_in)
                  del(.in_value_parts)
                }

                # Extract OUT interface
                if contains(.msg_str, "OUT=") {
                  .out_parts = split(.msg_str, "OUT=")
                  if length(.out_parts) >= 2 {
                    .after_out = .out_parts[1]
                    .out_value_parts = split!(.after_out, " ")
                    if length(.out_value_parts) >= 1 {
                      .out_interface = .out_value_parts[0]
                    }
                  }
                  del(.out_parts)
                  del(.after_out)
                  del(.out_value_parts)
                }

                # Extract MAC addresses
                if contains(.msg_str, "MAC=") {
                  .mac_parts = split(.msg_str, "MAC=")
                  if length(.mac_parts) >= 2 {
                    .after_mac = .mac_parts[1]
                    .mac_value_parts = split!(.after_mac, " ")
                    if length(.mac_value_parts) >= 1 {
                      .mac_address = .mac_value_parts[0]
                      # Split MAC into src and dst (first 17 chars is dst, next 17 is src)
                      if exists(.mac_address) && length(string!(.mac_address)) >= 35 {
                        .dst_mac = slice!(string!(.mac_address), 0, 17)
                        .src_mac = slice!(string!(.mac_address), 18, 35)
                      }
                    }
                  }
                  del(.mac_parts)
                  del(.after_mac)
                  del(.mac_value_parts)
                }

                # Extract source IP
                if contains(.msg_str, "SRC=") {
                  .src_parts = split(.msg_str, "SRC=")
                  if length(.src_parts) >= 2 {
                    .after_src = .src_parts[1]
                    .src_value_parts = split!(.after_src, " ")
                    if length(.src_value_parts) >= 1 {
                      .src_ip = .src_value_parts[0]
                      # Determine IP type
                      if contains(string!(.src_ip), ":") {
                        .src_ip_type = "ipv6"
                      } else {
                        .src_ip_type = "ipv4"
                      }
                    }
                  }
                  del(.src_parts)
                  del(.after_src)
                  del(.src_value_parts)
                }

                # Extract destination IP
                if contains(.msg_str, "DST=") {
                  .dst_parts = split(.msg_str, "DST=")
                  if length(.dst_parts) >= 2 {
                    .after_dst = .dst_parts[1]
                    .dst_value_parts = split!(.after_dst, " ")
                    if length(.dst_value_parts) >= 1 {
                      .dst_ip = .dst_value_parts[0]
                      # Determine IP type
                      if contains(string!(.dst_ip), ":") {
                        .dst_ip_type = "ipv6"
                      } else {
                        .dst_ip_type = "ipv4"
                      }
                    }
                  }
                  del(.dst_parts)
                  del(.after_dst)
                  del(.dst_value_parts)
                }

                # Extract source port
                if contains(.msg_str, "SPT=") {
                  .spt_parts = split(.msg_str, "SPT=")
                  if length(.spt_parts) >= 2 {
                    .after_spt = .spt_parts[1]
                    .spt_value_parts = split!(.after_spt, " ")
                    if length(.spt_value_parts) >= 1 {
                      .src_port = to_int!(.spt_value_parts[0])
                    }
                  }
                  del(.spt_parts)
                  del(.after_spt)
                  del(.spt_value_parts)
                }

                # Extract destination port
                if contains(.msg_str, "DPT=") {
                  .dpt_parts = split(.msg_str, "DPT=")
                  if length(.dpt_parts) >= 2 {
                    .after_dpt = .dpt_parts[1]
                    .dpt_value_parts = split!(.after_dpt, " ")
                    if length(.dpt_value_parts) >= 1 {
                      .dst_port = to_int!(.dpt_value_parts[0])
                    }
                  }
                  del(.dpt_parts)
                  del(.after_dpt)
                  del(.dpt_value_parts)
                }

                # Extract protocol
                if contains(.msg_str, "PROTO=") {
                  .proto_parts = split(.msg_str, "PROTO=")
                  if length(.proto_parts) >= 2 {
                    .after_proto = .proto_parts[1]
                    .proto_value_parts = split!(.after_proto, " ")
                    if length(.proto_value_parts) >= 1 {
                      .protocol = .proto_value_parts[0]
                    }
                  }
                  del(.proto_parts)
                  del(.after_proto)
                  del(.proto_value_parts)
                }

                # Extract packet length
                if contains(.msg_str, "LEN=") {
                  .len_parts = split(.msg_str, "LEN=")
                  if length(.len_parts) >= 2 {
                    .after_len = .len_parts[1]
                    .len_value_parts = split!(.after_len, " ")
                    if length(.len_value_parts) >= 1 {
                      .packet_length = to_int!(.len_value_parts[0])
                    }
                  }
                  del(.len_parts)
                  del(.after_len)
                  del(.len_value_parts)
                }

                # Extract TTL
                if contains(.msg_str, "TTL=") {
                  .ttl_parts = split(.msg_str, "TTL=")
                  if length(.ttl_parts) >= 2 {
                    .after_ttl = .ttl_parts[1]
                    .ttl_value_parts = split!(.after_ttl, " ")
                    if length(.ttl_value_parts) >= 1 {
                      .ttl = to_int!(.ttl_value_parts[0])
                    }
                  }
                  del(.ttl_parts)
                  del(.after_ttl)
                  del(.ttl_value_parts)
                }

                # Extract HOPLIMIT (for IPv6)
                if contains(.msg_str, "HOPLIMIT=") {
                  .hop_parts = split(.msg_str, "HOPLIMIT=")
                  if length(.hop_parts) >= 2 {
                    .after_hop = .hop_parts[1]
                    .hop_value_parts = split!(.after_hop, " ")
                    if length(.hop_value_parts) >= 1 {
                      .hop_limit = to_int!(.hop_value_parts[0])
                    }
                  }
                  del(.hop_parts)
                  del(.after_hop)
                  del(.hop_value_parts)
                }

                # Extract TCP flags
                .msg_str = to_string!(.msg_content)
                if contains(.msg_str, " SYN ") {
                  .tcp_flags = "SYN"
                }
                if contains(.msg_str, " ACK ") {
                  if exists(.tcp_flags) {
                    .tcp_flags = string!(.tcp_flags) + ",ACK"
                  } else {
                    .tcp_flags = "ACK"
                  }
                }
                if contains(.msg_str, " FIN ") {
                  if exists(.tcp_flags) {
                    .tcp_flags = string!(.tcp_flags) + ",FIN"
                  } else {
                    .tcp_flags = "FIN"
                  }
                }
                if contains(.msg_str, " RST ") {
                  if exists(.tcp_flags) {
                    .tcp_flags = string!(.tcp_flags) + ",RST"
                  } else {
                    .tcp_flags = "RST"
                  }
                }
                del(.msg_str)

                # Determine traffic direction based on RFC1918 private IP ranges
                if exists(.src_ip) && exists(.dst_ip) {
                  .src_ip_str = string!(.src_ip)
                  .dst_ip_str = string!(.dst_ip)

                  # Check if source IP is private (RFC1918)
                  .src_is_private = starts_with(.src_ip_str, "192.168.") || starts_with(.src_ip_str, "10.") ||
                                   (starts_with(.src_ip_str, "172.") &&
                                    (starts_with(.src_ip_str, "172.16.") || starts_with(.src_ip_str, "172.17.") ||
                                     starts_with(.src_ip_str, "172.18.") || starts_with(.src_ip_str, "172.19.") ||
                                     starts_with(.src_ip_str, "172.20.") || starts_with(.src_ip_str, "172.21.") ||
                                     starts_with(.src_ip_str, "172.22.") || starts_with(.src_ip_str, "172.23.") ||
                                     starts_with(.src_ip_str, "172.24.") || starts_with(.src_ip_str, "172.25.") ||
                                     starts_with(.src_ip_str, "172.26.") || starts_with(.src_ip_str, "172.27.") ||
                                     starts_with(.src_ip_str, "172.28.") || starts_with(.src_ip_str, "172.29.") ||
                                     starts_with(.src_ip_str, "172.30.") || starts_with(.src_ip_str, "172.31.")))

                  # Check if destination IP is private (RFC1918)
                  .dst_is_private = starts_with(.dst_ip_str, "192.168.") || starts_with(.dst_ip_str, "10.") ||
                                   (starts_with(.dst_ip_str, "172.") &&
                                    (starts_with(.dst_ip_str, "172.16.") || starts_with(.dst_ip_str, "172.17.") ||
                                     starts_with(.dst_ip_str, "172.18.") || starts_with(.dst_ip_str, "172.19.") ||
                                     starts_with(.dst_ip_str, "172.20.") || starts_with(.dst_ip_str, "172.21.") ||
                                     starts_with(.dst_ip_str, "172.22.") || starts_with(.dst_ip_str, "172.23.") ||
                                     starts_with(.dst_ip_str, "172.24.") || starts_with(.dst_ip_str, "172.25.") ||
                                     starts_with(.dst_ip_str, "172.26.") || starts_with(.dst_ip_str, "172.27.") ||
                                     starts_with(.dst_ip_str, "172.28.") || starts_with(.dst_ip_str, "172.29.") ||
                                     starts_with(.dst_ip_str, "172.30.") || starts_with(.dst_ip_str, "172.31.")))

                  if .src_is_private {
                    if .dst_is_private {
                      .traffic_direction = "internal"
                    } else {
                      .traffic_direction = "outbound"
                    }
                  } else {
                    .traffic_direction = "inbound"
                  }
                  del(.src_ip_str)
                  del(.dst_ip_str)
                  del(.src_is_private)
                  del(.dst_is_private)
                }
              } else {
                # System log
                ._msg = .msg_content
                .device_name = "unifi-uxg-system"
              }
            }
          } else {
            # Unknown format
            ._msg = .raw_message
            .device_name = "unifi-unknown"
          }

          # Set final fields for Victoria Logs
          ._stream = "network.unifi." + replace!(replace!(.device_ip, ".", "_"), ":", "_")
          ._time = to_string(now())
          .device_type = "unifi"
          .log_source = "network"
          .environment = "production"

          # Clean up intermediate fields
          del(.message)
          del(.parts)
          del(.cef_parts)
          del(.cef_fields)
          del(.header_parts)
          del(.extensions_str)
          del(.msg_match)
          del(.priority_str)
          del(.source_type)
          del(.port)
          del(.cef_data)

    # Sinks - Send to Victoria Logs
    sinks:
      victoria_logs:
        type: http
        inputs:
          - parse_cisco
          - parse_unifi
        uri: "http://victoria-logs-server.observability.svc.cluster.local:9428/insert/jsonline"
        method: post
        compression: gzip
        framing:
          method: newline_delimited
        encoding:
          codec: json
          only_fields:
            - _msg
            - _stream
            - _time
            - device_type
            - device_name
            - device_ip
            - device_hostname
            - log_source
            - environment
            - facility
            - severity
            - sequence
            - msg_id
            - event_id
            - event_name
            - vendor
            - product
            - version
            - message_type
            - raw_message
            # Network fields
            - src_ip
            - dst_ip
            - src_port
            - dst_port
            - protocol
            - src_ip_type
            - dst_ip_type
            - traffic_direction
            - mac_address
            - src_mac
            - dst_mac
            - in_interface
            - out_interface
            - packet_length
            - ttl
            - hop_limit
            - tcp_flags
        batch:
          max_bytes: 1048576
          max_events: 1000
          timeout_secs: 5
        buffer:
          type: memory
          max_events: 10000
        request:
          headers:
            Content-Type: "application/x-ndjson"
        healthcheck:
          enabled: true

      # Debug output to console
      debug_console:
        type: console
        inputs:
          - parse_cisco
          - parse_unifi
        encoding:
          codec: json
        target: stdout
